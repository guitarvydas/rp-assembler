(in-package :rp-assembler)

(defmethod skip-spaces-and-comments ((p parser))
  (cond ((eq :SPACE (token-kind (next-token p))))
	((eq :COMMENT (token-kind (next-token p))))
	(t (accept p))))
	 
(defmethod <rp> ((p parser))
  (rp-filter-stream p #'skip-spaces-and-comments)
  (@:loop
    (if (rpa:parser-success? (rpa:lookahead-char? p #\=))
	(<parse-rule> p)
	(if (rpa:parser-success? (rpa:lookahead-char? p #\-))
	    (<parse-predicate> p)
	    (@:exit-when t)))) ;; else exit
  (rpa:input p :EOF)
  )

(defmethod <filter-stream> ((p parser))
  (rpa:input-char p #\~)
  (rpa:input p :symbol)
  (rpa:emit-string p "(rp-filter-stream p #'~a)" (token-text (accepted-token p))))

(defmethod <parse-token-expr> ((p parser))
  (cond ((rpa:parser-success? (rpa:lookahead-char? p #\'))
	 (rpa:input-char p #\')
	 (input-any-character p)
             (rpa:emit-string p "(rpa:input-char p #\\~a)" (scanner:token-text (rpa:accepted-token p)))
         (rpa:input-char p #\')
	 rpa:+succeed+)
	((rpa:parser-success? (rp-assembler::look-upcase-symbol? p))
	 (input-upcase-symbol p)
	 (if (rpa:parser-success? (rpa:lookahead-char? p #\/))
	     ;; qualified token NAME/qual
             (progn
               (rpa:input-char p #\/)
	       ;; qual can be a SYMBOl or a single char
	       (if (rpa:parser-success? (lookahead? p :character))
		   (progn
		     (input-any-character p)
		     (rpa:emit-string p "(rpa:input-char p #\\~a)" (scanner:token-text (rpa:accepted-token p))))
		  (progn
		    (rpa:input p :symbol)
		    (rpa:emit-string p "(rpa:input-symbol p ~s)" (scanner:token-text (rpa:accepted-token p)))))
	       )
	   ;; unqualified token NAME
           (rpa:emit-string p "(rpa:input p :~a)" (scanner:token-text (rpa:accepted-token p))))
	 rpa:+succeed+)
	(t rpa:+fail+)))

(defmethod <parse-noop> ((p parser))
  (cond ((rpa:parser-success? (rpa:lookahead-char? p #\*))
	 (rpa:input-char p #\*)
             (rpa:emit-string p " t ")
	 rpa:+succeed+)
	(t rpa:+fail+)))

(defmethod <parse-dot> ((p parser))
  (cond ((rpa:parser-success? (rpa:lookahead-char? p #\.))
	 (rpa:input-char p #\.)
             (rpa:emit-string p " (rpa:accept p) ")
	 rpa:+succeed+)
	(t rpa:+fail+)))

(defmethod <parse-expr> ((p parser))
  (cond ((rpa:parser-success? (<parse-token-expr> p)) rpa:+succeed+)
	((rpa:parser-success? (<parse-noop> p))       rpa:+succeed+)
	((rpa:parser-success? (<parse-dot> p))        rpa:+succeed+)
	(t rpa:+fail+)))

(defmethod <parse-lookahead-token-expr> ((p parser))
  (cond ((rpa:parser-success? (rpa:lookahead-char? p #\'))
	 (rpa:input-char p #\')
	 (input-any-character p)
             (rpa:emit-string p "(rpa:parser-success? (rpa:lookahead-char? p #\\~a))" (scanner:token-text (rpa:accepted-token p)))
         (rpa:input-char p #\')
	 rpa:+succeed+)
	((rpa:parser-success? (rp-assembler::look-upcase-symbol? p))
	 (rp-assembler::input-upcase-symbol p)
	 (cond ((rpa:parser-success? (rpa:lookahead-char? p #\/))
                 ;; same as above (<parse-token-expr>) TOKEN/qual where qual can be a symbol or a character
                 ;; TOKEN/q where q is a :symbol or :character
                 (rpa:input-char p #\/)
                 (cond ((rpa:parser-success? (rpa:lookahead? p :character))
                        ;; q is :character
                        (input-any-character p)
			(rpa:emit-string p "(rpa:parser-success? (rpa:lookahead-char? p #\\~a))" (scanner:token-text (rpa:accepted-token p))))
                       ;; else q is :symbol
                       (t
                        (rpa:input p :symbol)
                        (rpa:emit-string p "(rpa:parser-success? (rpa:lookahead-symbol? p ~s))" (scanner:token-text (rpa:accepted-token p))))))
               (t (rpa:emit-string p "(rpa:parser-success? (rpa:lookahead? p :~a))" (scanner:token-text (rpa:accepted-token p)))))
         rpa:+succeed+)
        (t rpa:+fail+)))

(defmethod <parse-lookahead-noop> ((p parser))
  (cond ((rpa:parser-success? (rpa:lookahead-char? p #\*))
	 (rpa:input-char p #\*)
             (rpa:emit-string p " t ")
	 rpa:+succeed+)
	(t rpa:+fail+)))

(defmethod <parse-lookahead-expr> ((p parser))
  (cond ((rpa:parser-success? (<parse-lookahead-token-expr> p)) rpa:+succeed+)
	((rpa:parser-success? (<parse-lookahead-noop> p))       rpa:+succeed+)
	(t rpa:+fail+)))

(defmethod <parse-statement> ((p parser))
  (cond ((rpa:parser-success? (<parse-cycle> p)) rpa:+succeed+)
	((rpa:parser-success? (<parse-choice> p)) rpa:+succeed+)
	((rpa:parser-success? (<parse-return> p)) rpa:+succeed+)
	((rpa:parser-success? (<parse-cycle-exit> p)) rpa:+succeed+)
	((rpa:parser-success? (<parse-input-token> p)) rpa:+succeed+)
	((rpa:parser-success? (<parse-lookahead> p)) rpa:+succeed+)
	((rpa:parser-success? (<parse-noop> p)) rpa:+succeed+)
	((rpa:parser-success? (<parse-dot> p)) rpa:+succeed+)
	((rpa:parser-success? (<parse-rule-call> p)) rpa:+succeed+)
	((rpa:parser-success? (<parse-predicate-call> p)) rpa:+succeed+)
	((rpa:parser-success? (<parse-external-call> p)) rpa:+succeed+)
	((rpa:parser-success? (rpa:lookahead-char? p #\~)) (<filter-stream> p) rpa:+succeed+)
	(t rpa:+fail+)))

(defmethod <parse-statements> ((p parser))
  (let ((result rpa:+fail+))
  (@:loop
   (@:exit-when (not (rpa:parser-success? (<parse-statement> p))))
   (rpa:emit-string p "~%")
   (setf result rpa:+succeed+))
  result))

(defmethod <parse-choice-statements> ((p parser))
  (let ((result rpa:+fail+))
  (@:loop
   (@:exit-when (not (rpa:parser-success? (<parse-statement> p))))
   (setf result rpa:+succeed+))
  result))

(defmethod <parse-cycle> ((p parser))
  (cond ((rpa:parser-success? (rpa:lookahead-char? p #\{))
	 (rpa:input-char p #\{)
                 (rpa:emit-string p "~&(loop~%")
	 (<parse-statements> p)
	 (rpa:input-char p #\})
                 (rpa:emit-string p ")~%")
	 rpa:+succeed+)
	(t rpa:+fail+)))

(defmethod <parse-choice> ((p parser))
  (cond ((rpa:parser-success? (rpa:lookahead-char? p #\[))
	 (rpa:input-char p #\[)
             (rpa:emit-string p "~&(cond~%")
             (rpa:emit-string p "(")
	 (<parse-choice-statements> p)
             (rpa:emit-string p ")~%")
         (@:loop
           (@:exit-when (not (rpa:parser-success? (rpa:lookahead-char? p #\|))))
           (rpa:input-char p #\|)
               (rpa:emit-string p "(")
           (<parse-statements> p)
               (rpa:emit-string p ")~%"))
	 (rpa:input-char p #\])
            (rpa:emit-string p ")~%")
	 rpa:+succeed+)
	(t rpa:+fail+)))

(defmethod <parse-choice-alternate> ((p parser))
  (cond ((rpa:parser-success? (rpa:lookahead-char? p #\|))
	 (rpa:input-char p #\|)
             (rpa:emit-string p "(")
	 (<parse-statements> p)
             (rpa:emit-string p ")~%")
	 rpa:+succeed+)
	(t rpa:+fail+)))

(defmethod <parse-input-token> ((p parser))
  (<parse-expr> p))

(defmethod error-if-not-success ((p parser) value)
  (if (eq rpa:+succeed+ value)
      rpa:+succeed+
      (rp-parse-error p "")))

(defmethod <parse-lookahead> ((p parser))
  (cond ((rpa:parser-success? (rpa:lookahead-char? p #\?))
	 (rpa:input-char p #\?)
	 (error-if-not-success p (<parse-lookahead-expr> p))
	 rpa:+succeed+)
	(t rpa:+fail+)))
  
(defmethod <parse-rule-call> ((p parser))
  (cond ((rpa:parser-success? (rpa:lookahead-char? p #\@))
	 (rpa:input-char p #\@)
	 (rpa:input p :symbol)
            (rpa:emit-string p "(rpa:call-rule p #'~a)" (scanner:token-text (rpa:accepted-token p)))
	 rpa:+succeed+)
	(t rpa:+fail+)))

(defmethod <parse-predicate-call> ((p parser))
  (cond ((rpa:parser-success? (rpa:lookahead-char? p #\&))
	 (rpa:input-char p #\&)
	 (rpa:input p :symbol)
            (rpa:emit-string p "(rpa:parser-success? (rpa:call-predicate p #'~a))" (scanner:token-text (rpa:accepted-token p)))
	 rpa:+succeed+)
	(t rpa:+fail+)))

(defmethod <parse-external-call> ((p parser))
  (cond ((rpa:parser-success? (lookahead? p :symbol))
	 (rpa:input p :symbol)
               (rpa:emit-string p "(rpa:call-external p #'~a)" (scanner:token-text (rpa:accepted-token p)))
	 rpa:+succeed+)
	(t rpa:+fail+)))

(defmethod <parse-cycle-exit> ((p parser))
  (cond ((rpa:parser-success? (rpa:lookahead-char? p #\>))
	 (rpa:input-char p #\>)
           (rpa:emit-string p "(return)")
	 rpa:+succeed+)
	(t rpa:+fail+)))

(defmethod <parse-return> ((p parser))
  (cond ((rpa:parser-success? (rpa:lookahead-char? p #\^))
	 (rpa:input-char p #\^)
	 (rpa:input p :symbol)
	 (error-if-not-success p
	  (if (string= "fail" (scanner:token-text (rpa:accepted-token p)))
	      (progn
                      (rpa:emit-string p "(return-from ~a rpa:+fail+)" (rpa::current-rule p))
                rpa:+succeed+)
	      (if (string= "ok" (scanner:token-text (rpa:accepted-token p)))
		  (progn
                      (rpa:emit-string p "(return-from ~a rpa:+succeed+)" (rpa::current-rule p))
                    rpa:+succeed+)
		  rpa:+fail+)))
	 rpa:+succeed+)
	(t rpa:+fail+)))
  
(defmethod <parse-rule> ((p parser))
  (rpa:input-char p #\=)
  (rpa:input p :symbol)
  (setf (rpa::current-rule p) (scanner:token-text (rpa:accepted-token p)))
             (rpa:emit-string p "(defmethod ~a ((p rpa:parser))~%" (rpa::current-rule p))
  (<parse-statements> p)
             (rpa:emit-string p ")~%~%")
  rpa:+succeed+
  )

(defmethod <parse-predicate> ((p parser))
  (rpa:input-char p #\-)
  (rpa:input p :symbol)
  (setf (rpa::current-rule p) (scanner:token-text (rpa:accepted-token p)))
             (rpa:emit-string p "(defmethod ~a ((p rpa:parser)) ;; predicate~%" (rpa::current-rule p))
  (<parse-statements> p)
             (rpa:emit-string p ")~%~%")
  rpa:+succeed+
  )

